[kernel] Parsing tests/variables/variables.c (with preprocessing)
[c2s] Generating f_char_17 function
[c2s] Finalizing
[c2s] Generating f_char_18 function
[c2s] Finalizing
[c2s] Generating f_char_20 function
[c2s] Finalizing
[c2s] Generating f_char_21 function
[c2s] Finalizing
[c2s] Generating f_char_23 function
[c2s] Finalizing
[c2s] Generating f_char_107 function
[c2s] Finalizing
[c2s] Generating f_char_108 function
[c2s] Finalizing
[c2s] Generating f_char_109 function
[c2s] Finalizing
[c2s] Generating f_char_110 function
[c2s] Finalizing
[c2s] Generating f_char_111 function
[c2s] Finalizing
[c2s] Generating f_char_112 function
[c2s] Finalizing
[c2s] Generating f_char_29 function
[c2s] Finalizing
[c2s] Generating f_char_51 function
[c2s] Finalizing
[c2s] Generating f_int_1 function
[c2s] Finalizing
[c2s] Generating f_int_2 function
[c2s] Finalizing
[c2s] Generating f_int_4 function
[c2s] Finalizing
[c2s] Generating f_int_5 function
[c2s] Finalizing
[c2s] Generating f_int_7 function
[c2s] Finalizing
[c2s] Generating f_int_100 function
[c2s] Finalizing
[c2s] Generating f_int_101 function
[c2s] Finalizing
[c2s] Generating f_int_102 function
[c2s] Finalizing
[c2s] Generating f_int_103 function
[c2s] Finalizing
[c2s] Generating f_int_104 function
[c2s] Finalizing
[c2s] Generating f_int_105 function
[c2s] Finalizing
[c2s] Generating f_int_13 function
[c2s] Finalizing
[c2s] Generating f_int_49 function
[c2s] Finalizing
[c2s] Generating f_struct_33 function
[c2s] Finalizing
[c2s] Generating f_struct_34 function
[c2s] Finalizing
[c2s] Generating f_struct_36 function
[c2s] Finalizing
[c2s] Generating f_struct_37 function
[c2s] Finalizing
[c2s] Generating f_struct_39 function
[c2s] Finalizing
[c2s] Generating f_struct_114 function
[c2s] Finalizing
[c2s] Generating f_struct_115 function
[c2s] Finalizing
[c2s] Generating f_struct_116 function
[c2s] Finalizing
[c2s] Generating f_struct_117 function
[c2s] Finalizing
[c2s] Generating f_struct_118 function
[c2s] Finalizing
[c2s] Generating f_struct_119 function
[c2s] Finalizing
[c2s] Generating f_struct_45 function
[c2s] Finalizing
[c2s] Generating f_struct_53 function
[c2s] Finalizing
[c2s] Generating interleaving function
[c2s] Building axiomatic block about simulating variables
[c2s] Building validity axiom for pc
[c2s] Building validity axiom for tl_tlpas
[c2s] Building validity axiom for tl_tlaps
[c2s] Building validity axiom for tl_tlas
[c2s] Building validity axiom for tl_tlps
[c2s] Building validity axiom for tl_tls
[c2s] Building validity axiom for tl_tlpac
[c2s] Building validity axiom for tl_tlapc
[c2s] Building validity axiom for tl_tlac
[c2s] Building validity axiom for tl_tlpc
[c2s] Building validity axiom for tl_tlc
[c2s] Building validity axiom for tl_tlpai
[c2s] Building validity axiom for tl_tlapi
[c2s] Building validity axiom for tl_tlai
[c2s] Building validity axiom for tl_tlpi
[c2s] Building validity axiom for tl_tli
[c2s] Building validity axiom for f_struct_fpa44
[c2s] Building validity axiom for f_struct_fap43
[c2s] Building validity axiom for f_struct_fa42
[c2s] Building validity axiom for f_char_fpa28
[c2s] Building validity axiom for f_char_fap27
[c2s] Building validity axiom for f_char_fa26
[c2s] Building validity axiom for f_int_fpa12
[c2s] Building validity axiom for f_int_fap11
[c2s] Building validity axiom for f_int_fa10
[c2s] Building validity axiom for f_struct_i
[c2s] Building validity axiom for f_struct_lpa
[c2s] Building validity axiom for f_struct_lap
[c2s] Building validity axiom for f_struct_la
[c2s] Building validity axiom for f_struct_lp
[c2s] Building validity axiom for f_struct_l
[c2s] Building validity axiom for f_struct_fpa
[c2s] Building validity axiom for f_struct_fap
[c2s] Building validity axiom for f_struct_fa
[c2s] Building validity axiom for f_struct_fp
[c2s] Building validity axiom for f_struct_f
[c2s] Building validity axiom for f_char_i
[c2s] Building validity axiom for f_char_lpa
[c2s] Building validity axiom for f_char_lap
[c2s] Building validity axiom for f_char_la
[c2s] Building validity axiom for f_char_lp
[c2s] Building validity axiom for f_char_l
[c2s] Building validity axiom for f_char_fpa
[c2s] Building validity axiom for f_char_fap
[c2s] Building validity axiom for f_char_fa
[c2s] Building validity axiom for f_char_fp
[c2s] Building validity axiom for f_char_f
[c2s] Building validity axiom for f_int_i
[c2s] Building validity axiom for f_int_lpa
[c2s] Building validity axiom for f_int_lap
[c2s] Building validity axiom for f_int_la
[c2s] Building validity axiom for f_int_lp
[c2s] Building validity axiom for f_int_l
[c2s] Building validity axiom for f_int_fpa
[c2s] Building validity axiom for f_int_fap
[c2s] Building validity axiom for f_int_fa
[c2s] Building validity axiom for f_int_fp
[c2s] Building validity axiom for f_int_f
[c2s] Building validity axiom for next_in_f_struct
[c2s] Building validity axiom for next_in_f_char
[c2s] Building validity axiom for next_in_f_int
[c2s] Building axiom about simulating variables separation
[c2s] Warning: gpas is a pointer, separation with simulation is not currently supported (ignored)
[c2s] Warning: gps is a pointer, separation with simulation is not currently supported (ignored)
[c2s] Warning: gpac is a pointer, separation with simulation is not currently supported (ignored)
[c2s] Warning: gpc is a pointer, separation with simulation is not currently supported (ignored)
[c2s] Warning: gpai is a pointer, separation with simulation is not currently supported (ignored)
[c2s] Warning: gpi is a pointer, separation with simulation is not currently supported (ignored)
[c2s] /* Generated by Frama-C */
  #include "stddef.h"
  int *pc;
  struct type;
  struct type (**tl_tlpas)[10];
  struct type *(*tl_tlaps)[10];
  struct type (*tl_tlas)[10];
  struct type **tl_tlps;
  struct type *tl_tls;
  char (**tl_tlpac)[10];
  char *(*tl_tlapc)[10];
  char (*tl_tlac)[10];
  char **tl_tlpc;
  char *tl_tlc;
  int (**tl_tlpai)[10];
  int *(*tl_tlapi)[10];
  int (*tl_tlai)[10];
  int **tl_tlpi;
  int *tl_tli;
  struct type *f_struct_fpa44;
  struct type **f_struct_fap43;
  struct type *f_struct_fa42;
  char *f_char_fpa28;
  char **f_char_fap27;
  char *f_char_fa26;
  int *f_int_fpa12;
  int **f_int_fap11;
  int *f_int_fa10;
  int *f_struct_i;
  struct type (**f_struct_lpa)[10];
  struct type *(*f_struct_lap)[10];
  struct type (*f_struct_la)[10];
  struct type **f_struct_lp;
  struct type *f_struct_l;
  struct type (**f_struct_fpa)[10];
  struct type ** /*[10]*/ *f_struct_fap;
  struct type * /*[10]*/ *f_struct_fa;
  struct type **f_struct_fp;
  struct type *f_struct_f;
  int *f_char_i;
  char (**f_char_lpa)[10];
  char *(*f_char_lap)[10];
  char (*f_char_la)[10];
  char **f_char_lp;
  char *f_char_l;
  char (**f_char_fpa)[10];
  char ** /*[10]*/ *f_char_fap;
  char * /*[10]*/ *f_char_fa;
  char **f_char_fp;
  char *f_char_f;
  int *f_int_i;
  int (**f_int_lpa)[10];
  int *(*f_int_lap)[10];
  int (*f_int_la)[10];
  int **f_int_lp;
  int *f_int_l;
  int (**f_int_fpa)[10];
  int ** /*[10]*/ *f_int_fap;
  int * /*[10]*/ *f_int_fa;
  int **f_int_fp;
  int *f_int_f;
  int *next_in_f_struct;
  int *next_in_f_char;
  int *next_in_f_int;
  /*@
  predicate valid_pc{L}(ℤ pc) =
    pc ≡ 0 ∨
    pc ≡ -95 ∨
    pc ≡ -78 ∨
    pc ≡ -61 ∨
    pc ≡ 119 ∨
    pc ≡ 118 ∨
    pc ≡ 117 ∨
    pc ≡ 116 ∨
    pc ≡ 115 ∨
    pc ≡ 114 ∨
    pc ≡ 112 ∨
    pc ≡ 111 ∨
    pc ≡ 110 ∨
    pc ≡ 109 ∨
    pc ≡ 108 ∨
    pc ≡ 107 ∨
    pc ≡ 105 ∨
    pc ≡ 104 ∨
    pc ≡ 103 ∨
    pc ≡ 102 ∨
    pc ≡ 101 ∨
    pc ≡ 100 ∨
    pc ≡ 53 ∨
    pc ≡ 51 ∨
    pc ≡ 49 ∨
    pc ≡ 45 ∨
    pc ≡ 39 ∨
    pc ≡ 37 ∨
    pc ≡ 36 ∨
    pc ≡ 34 ∨
    pc ≡ 33 ∨
    pc ≡ 29 ∨
    pc ≡ 23 ∨
    pc ≡ 21 ∨
    pc ≡ 20 ∨
    pc ≡ 18 ∨
    pc ≡ 17 ∨
    pc ≡ 13 ∨ pc ≡ 7 ∨ pc ≡ 5 ∨ pc ≡ 4 ∨ pc ≡ 2 ∨ pc ≡ 1;
   */
  /*@
  predicate valid_pcs{L}(ℤ th) =
    valid_pc(*(pc + th)) ∧
    valid_pc(*(next_in_f_struct + th)) ∧
    valid_pc(*(next_in_f_char + th)) ∧ valid_pc(*(next_in_f_int + th));
  
  */
  struct type *gaps[10];
  
  struct type gas[10];
  
  struct type gs;
  
  char *gapc[10];
  
  char gac[10];
  
  char gc;
  
  int *gapi[10];
  
  int gai[10];
  
  int gi;
  
  /*@ ghost size_t world; */
  
  /*@
  axiomatic thread_variables_properties {
    logic ℤ MAX_THREAD
      reads \nothing;
    
    axiom some_threads: 0 < MAX_THREAD;
    
    }
   */
  /*@ predicate valid_thread_id(ℤ th) = 0 ≤ th < MAX_THREAD;
   */
  /*@
  axiomatic Simulation_axioms {
    predicate simulation{L}
      reads
      pc, tl_tlpas, tl_tlaps, tl_tlas, tl_tlps, tl_tls, tl_tlpac, tl_tlapc,
      tl_tlac, tl_tlpc, tl_tlc, tl_tlpai, tl_tlapi, tl_tlai, tl_tlpi, tl_tli,
      f_struct_fpa44, f_struct_fap43, f_struct_fa42, f_char_fpa28,
      f_char_fap27, f_char_fa26, f_int_fpa12, f_int_fap11, f_int_fa10,
      f_struct_i, f_struct_lpa, f_struct_lap, f_struct_la, f_struct_lp,
      f_struct_l, f_struct_fpa, f_struct_fap, f_struct_fa, f_struct_fp,
      f_struct_f, f_char_i, f_char_lpa, f_char_lap, f_char_la, f_char_lp,
      f_char_l, f_char_fpa, f_char_fap, f_char_fa, f_char_fp, f_char_f,
      f_int_i, f_int_lpa, f_int_lap, f_int_la, f_int_lp, f_int_l, f_int_fpa,
      f_int_fap, f_int_fa, f_int_fp, f_int_f, next_in_f_struct, next_in_f_char,
      next_in_f_int;
    
    axiom all_separated{L}:
      simulation ⇒
      \separated(
        &gaps[0 .. 10 - 1], &gas[0 .. 10 - 1], &gs, &gapc[0 .. 10 - 1],
        &gac[0 .. 10 - 1], &gc, &gapi[0 .. 10 - 1], &gai[0 .. 10 - 1], &gi,
        &world, pc + (0 .. MAX_THREAD - 1), tl_tlpas + (0 .. MAX_THREAD - 1),
        tl_tlaps + (0 .. MAX_THREAD - 1), tl_tlas + (0 .. MAX_THREAD - 1),
        tl_tlps + (0 .. MAX_THREAD - 1), tl_tls + (0 .. MAX_THREAD - 1),
        tl_tlpac + (0 .. MAX_THREAD - 1), tl_tlapc + (0 .. MAX_THREAD - 1),
        tl_tlac + (0 .. MAX_THREAD - 1), tl_tlpc + (0 .. MAX_THREAD - 1),
        tl_tlc + (0 .. MAX_THREAD - 1), tl_tlpai + (0 .. MAX_THREAD - 1),
        tl_tlapi + (0 .. MAX_THREAD - 1), tl_tlai + (0 .. MAX_THREAD - 1),
        tl_tlpi + (0 .. MAX_THREAD - 1), tl_tli + (0 .. MAX_THREAD - 1),
        f_struct_fpa44 + (0 .. MAX_THREAD - 1),
        f_struct_fap43 + (0 .. MAX_THREAD - 1),
        f_struct_fa42 + (0 .. MAX_THREAD - 1),
        f_char_fpa28 + (0 .. MAX_THREAD - 1),
        f_char_fap27 + (0 .. MAX_THREAD - 1),
        f_char_fa26 + (0 .. MAX_THREAD - 1),
        f_int_fpa12 + (0 .. MAX_THREAD - 1),
        f_int_fap11 + (0 .. MAX_THREAD - 1),
        f_int_fa10 + (0 .. MAX_THREAD - 1), f_struct_i + (0 .. MAX_THREAD - 1),
        f_struct_lpa + (0 .. MAX_THREAD - 1),
        f_struct_lap + (0 .. MAX_THREAD - 1),
        f_struct_la + (0 .. MAX_THREAD - 1),
        f_struct_lp + (0 .. MAX_THREAD - 1),
        f_struct_l + (0 .. MAX_THREAD - 1),
        f_struct_fpa + (0 .. MAX_THREAD - 1),
        f_struct_fap + (0 .. MAX_THREAD - 1),
        f_struct_fa + (0 .. MAX_THREAD - 1),
        f_struct_fp + (0 .. MAX_THREAD - 1),
        f_struct_f + (0 .. MAX_THREAD - 1), f_char_i + (0 .. MAX_THREAD - 1),
        f_char_lpa + (0 .. MAX_THREAD - 1), f_char_lap + (0 .. MAX_THREAD - 1),
        f_char_la + (0 .. MAX_THREAD - 1), f_char_lp + (0 .. MAX_THREAD - 1),
        f_char_l + (0 .. MAX_THREAD - 1), f_char_fpa + (0 .. MAX_THREAD - 1),
        f_char_fap + (0 .. MAX_THREAD - 1), f_char_fa + (0 .. MAX_THREAD - 1),
        f_char_fp + (0 .. MAX_THREAD - 1), f_char_f + (0 .. MAX_THREAD - 1),
        f_int_i + (0 .. MAX_THREAD - 1), f_int_lpa + (0 .. MAX_THREAD - 1),
        f_int_lap + (0 .. MAX_THREAD - 1), f_int_la + (0 .. MAX_THREAD - 1),
        f_int_lp + (0 .. MAX_THREAD - 1), f_int_l + (0 .. MAX_THREAD - 1),
        f_int_fpa + (0 .. MAX_THREAD - 1), f_int_fap + (0 .. MAX_THREAD - 1),
        f_int_fa + (0 .. MAX_THREAD - 1), f_int_fp + (0 .. MAX_THREAD - 1),
        f_int_f + (0 .. MAX_THREAD - 1),
        next_in_f_struct + (0 .. MAX_THREAD - 1),
        next_in_f_char + (0 .. MAX_THREAD - 1),
        next_in_f_int + (0 .. MAX_THREAD - 1)
        );
    
    axiom pc_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(pc + j));
    
    axiom tl_tlpas_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpas + j));
    
    axiom tl_tlaps_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlaps + j));
    
    axiom tl_tlas_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlas + j));
    
    axiom tl_tlps_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlps + j));
    
    axiom tl_tls_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tls + j));
    
    axiom tl_tlpac_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpac + j));
    
    axiom tl_tlapc_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapc + j));
    
    axiom tl_tlac_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlac + j));
    
    axiom tl_tlpc_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpc + j));
    
    axiom tl_tlc_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlc + j));
    
    axiom tl_tlpai_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpai + j));
    
    axiom tl_tlapi_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapi + j));
    
    axiom tl_tlai_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlai + j));
    
    axiom tl_tlpi_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpi + j));
    
    axiom tl_tli_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tli + j));
    
    axiom f_struct_fpa44_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa44 + j));
    
    axiom f_struct_fap43_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap43 + j));
    
    axiom f_struct_fa42_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa42 + j));
    
    axiom f_char_fpa28_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa28 + j));
    
    axiom f_char_fap27_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap27 + j));
    
    axiom f_char_fa26_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa26 + j));
    
    axiom f_int_fpa12_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa12 + j));
    
    axiom f_int_fap11_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap11 + j));
    
    axiom f_int_fa10_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa10 + j));
    
    axiom f_struct_i_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_i + j));
    
    axiom f_struct_lpa_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lpa + j));
    
    axiom f_struct_lap_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lap + j));
    
    axiom f_struct_la_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_la + j));
    
    axiom f_struct_lp_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lp + j));
    
    axiom f_struct_l_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_l + j));
    
    axiom f_struct_fpa_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa + j));
    
    axiom f_struct_fap_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap + j));
    
    axiom f_struct_fa_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa + j));
    
    axiom f_struct_fp_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fp + j));
    
    axiom f_struct_f_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_f + j));
    
    axiom f_char_i_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_i + j));
    
    axiom f_char_lpa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lpa + j));
    
    axiom f_char_lap_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lap + j));
    
    axiom f_char_la_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_la + j));
    
    axiom f_char_lp_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lp + j));
    
    axiom f_char_l_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_l + j));
    
    axiom f_char_fpa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa + j));
    
    axiom f_char_fap_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap + j));
    
    axiom f_char_fa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa + j));
    
    axiom f_char_fp_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fp + j));
    
    axiom f_char_f_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_f + j));
    
    axiom f_int_i_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_i + j));
    
    axiom f_int_lpa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lpa + j));
    
    axiom f_int_lap_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lap + j));
    
    axiom f_int_la_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_la + j));
    
    axiom f_int_lp_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lp + j));
    
    axiom f_int_l_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_l + j));
    
    axiom f_int_fpa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa + j));
    
    axiom f_int_fap_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap + j));
    
    axiom f_int_fa_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa + j));
    
    axiom f_int_fp_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fp + j));
    
    axiom f_int_f_is_valid{L}:
      simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_f + j));
    
    axiom next_in_f_struct_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_struct + j));
    
    axiom next_in_f_char_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_char + j));
    
    axiom next_in_f_int_is_valid{L}:
      simulation ⇒
      (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_int + j));
    
    }
  
  */
  struct type {
     int x ;
     char y ;
  };
  /*@ ghost size_t world; */
  /*@ ensures valid_thread_id(\result);
      atomic \true;
      assigns world; */
  size_t some_thread();
  
  int gi;
  int *gpi;
  int gai[10];
  int *gapi[10];
  int (*gpai)[10];
  char gc;
  char *gpc;
  char gac[10];
  char *gapc[10];
  char (*gpac)[10];
  struct type gs;
  struct type *gps;
  struct type gas[10];
  struct type *gaps[10];
  struct type (*gpas)[10];
  /*@ requires *(pc + th) ≡ -61;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 1;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void init_formals_f_int(unsigned int th);
  
  /*@ requires *(pc + th) ≡ -78;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 17;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void init_formals_f_char(unsigned int th);
  
  /*@ requires *(pc + th) ≡ -95;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 33;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void init_formals_f_struct(unsigned int th);
  
  /*@ requires *(pc + th) ≡ 1;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 2;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_1(unsigned int th)
  {
    *(f_int_l + th) = *(f_int_f + th);
    *(pc + th) = 2;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 2;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 4;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_2(unsigned int th)
  {
    *(f_int_lp + th) = *(f_int_fp + th);
    *(pc + th) = 4;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 4;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 5;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_4(unsigned int th)
  {
    *(f_int_i + th) = 0;
    *(pc + th) = 5;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 5;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 7;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_5(unsigned int th)
  {
    *(pc + th) = 7;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 7;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 100 ∨ *(pc + th) ≡ 49;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_7(unsigned int th)
  {
    if (*(f_int_i + th) < 10) *(pc + th) = 100; else *(pc + th) = 49;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 13;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 5;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_13(unsigned int th)
  {
    (*(f_int_i + th)) ++;
    *(pc + th) = 5;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 17;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 18;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_17(unsigned int th)
  {
    *(f_char_l + th) = *(f_char_f + th);
    *(pc + th) = 18;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 18;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 20;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_18(unsigned int th)
  {
    *(f_char_lp + th) = *(f_char_fp + th);
    *(pc + th) = 20;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 20;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 21;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_20(unsigned int th)
  {
    *(f_char_i + th) = 0;
    *(pc + th) = 21;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 21;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 23;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_21(unsigned int th)
  {
    *(pc + th) = 23;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 23;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 107 ∨ *(pc + th) ≡ 51;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_23(unsigned int th)
  {
    if (*(f_char_i + th) < 10) *(pc + th) = 107; else *(pc + th) = 51;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 29;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 21;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_29(unsigned int th)
  {
    (*(f_char_i + th)) ++;
    *(pc + th) = 21;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 33;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 34;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_33(unsigned int th)
  {
    *(f_struct_l + th) = *(f_struct_f + th);
    *(pc + th) = 34;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 34;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 36;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_34(unsigned int th)
  {
    *(f_struct_lp + th) = *(f_struct_fp + th);
    *(pc + th) = 36;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 36;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 37;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_36(unsigned int th)
  {
    *(f_struct_i + th) = 0;
    *(pc + th) = 37;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 37;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 39;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_37(unsigned int th)
  {
    *(pc + th) = 39;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 39;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 114 ∨ *(pc + th) ≡ 53;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_39(unsigned int th)
  {
    if (*(f_struct_i + th) < 10) *(pc + th) = 114; else *(pc + th) = 53;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 45;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 37;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_45(unsigned int th)
  {
    (*(f_struct_i + th)) ++;
    *(pc + th) = 37;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 49;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_49(unsigned int th)
  {
    *(pc + th) = *(next_in_f_int + th);
    return;
  }
  
  /*@ requires *(pc + th) ≡ 51;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_51(unsigned int th)
  {
    *(pc + th) = *(next_in_f_char + th);
    return;
  }
  
  /*@ requires *(pc + th) ≡ 53;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_53(unsigned int th)
  {
    *(pc + th) = *(next_in_f_struct + th);
    return;
  }
  
  /*@ requires *(pc + th) ≡ 100;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 101;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_100(unsigned int th)
  {
    *(f_int_fa10 + th) = *(*(f_int_fa + th) + *(f_int_i + th));
    *(pc + th) = 101;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 101;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 102;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_101(unsigned int th)
  {
    (*(f_int_la + th))[*(f_int_i + th)] = *(f_int_fa10 + th);
    *(pc + th) = 102;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 102;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 103;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_102(unsigned int th)
  {
    *(f_int_fap11 + th) = *(*(f_int_fap + th) + *(f_int_i + th));
    *(pc + th) = 103;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 103;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 104;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_103(unsigned int th)
  {
    (*(f_int_lap + th))[*(f_int_i + th)] = *(f_int_fap11 + th);
    *(pc + th) = 104;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 104;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 105;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_104(unsigned int th)
  {
    *(f_int_fpa12 + th) = (*(*(f_int_fpa + th) + *(f_int_i + th)))[0];
    *(pc + th) = 105;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 105;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 13;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_int_105(unsigned int th)
  {
    (*(*(f_int_lpa + th) + *(f_int_i + th)))[0] = *(f_int_fpa12 + th);
    *(pc + th) = 13;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 107;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 108;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_107(unsigned int th)
  {
    *(f_char_fa26 + th) = *(*(f_char_fa + th) + *(f_char_i + th));
    *(pc + th) = 108;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 108;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 109;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_108(unsigned int th)
  {
    (*(f_char_la + th))[*(f_char_i + th)] = *(f_char_fa26 + th);
    *(pc + th) = 109;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 109;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 110;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_109(unsigned int th)
  {
    *(f_char_fap27 + th) = *(*(f_char_fap + th) + *(f_char_i + th));
    *(pc + th) = 110;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 110;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 111;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_110(unsigned int th)
  {
    (*(f_char_lap + th))[*(f_char_i + th)] = *(f_char_fap27 + th);
    *(pc + th) = 111;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 111;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 112;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_111(unsigned int th)
  {
    *(f_char_fpa28 + th) = (*(*(f_char_fpa + th) + *(f_char_i + th)))[0];
    *(pc + th) = 112;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 112;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 29;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_char_112(unsigned int th)
  {
    (*(*(f_char_lpa + th) + *(f_char_i + th)))[0] = *(f_char_fpa28 + th);
    *(pc + th) = 29;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 114;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 115;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_114(unsigned int th)
  {
    *(f_struct_fa42 + th) = *(*(f_struct_fa + th) + *(f_struct_i + th));
    *(pc + th) = 115;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 115;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 116;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_115(unsigned int th)
  {
    (*(f_struct_la + th))[*(f_struct_i + th)] = *(f_struct_fa42 + th);
    *(pc + th) = 116;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 116;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 117;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_116(unsigned int th)
  {
    *(f_struct_fap43 + th) = *(*(f_struct_fap + th) + *(f_struct_i + th));
    *(pc + th) = 117;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 117;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 118;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_117(unsigned int th)
  {
    (*(f_struct_lap + th))[*(f_struct_i + th)] = *(f_struct_fap43 + th);
    *(pc + th) = 118;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 118;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 119;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_118(unsigned int th)
  {
    *(f_struct_fpa44 + th) = (*(*(f_struct_fpa + th) + *(f_struct_i + th)))[0];
    *(pc + th) = 119;
    return;
  }
  
  /*@ requires *(pc + th) ≡ 119;
      requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      requires valid_thread_id(th);
      ensures *(pc + th) ≡ 45;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void f_struct_119(unsigned int th)
  {
    (*(*(f_struct_lpa + th) + *(f_struct_i + th)))[0] = *(f_struct_fpa44 + th);
    *(pc + th) = 45;
    return;
  }
  
  /*@ requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
      ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      ensures simulation;
   */
  void choose_call(unsigned int th);
  
  /*@ requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
      requires simulation;
   */
  void interleave(void)
  {
    unsigned int th;
    th = some_thread();
    /*@ loop invariant C2S: simulation;
        loop invariant C2S: ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
    */
    while (1) {
      th = some_thread();
      switch (*(pc + th)) {
        case 0: choose_call(th);
        break;
        case -61: init_formals_f_int(th);
        break;
        case -78: init_formals_f_char(th);
        break;
        case -95: init_formals_f_struct(th);
        break;
        case 1: f_int_1(th);
        break;
        case 2: f_int_2(th);
        break;
        case 4: f_int_4(th);
        break;
        case 5: f_int_5(th);
        break;
        case 7: f_int_7(th);
        break;
        case 13: f_int_13(th);
        break;
        case 17: f_char_17(th);
        break;
        case 18: f_char_18(th);
        break;
        case 20: f_char_20(th);
        break;
        case 21: f_char_21(th);
        break;
        case 23: f_char_23(th);
        break;
        case 29: f_char_29(th);
        break;
        case 33: f_struct_33(th);
        break;
        case 34: f_struct_34(th);
        break;
        case 36: f_struct_36(th);
        break;
        case 37: f_struct_37(th);
        break;
        case 39: f_struct_39(th);
        break;
        case 45: f_struct_45(th);
        break;
        case 49: f_int_49(th);
        break;
        case 51: f_char_51(th);
        break;
        case 53: f_struct_53(th);
        break;
        case 100: f_int_100(th);
        break;
        case 101: f_int_101(th);
        break;
        case 102: f_int_102(th);
        break;
        case 103: f_int_103(th);
        break;
        case 104: f_int_104(th);
        break;
        case 105: f_int_105(th);
        break;
        case 107: f_char_107(th);
        break;
        case 108: f_char_108(th);
        break;
        case 109: f_char_109(th);
        break;
        case 110: f_char_110(th);
        break;
        case 111: f_char_111(th);
        break;
        case 112: f_char_112(th);
        break;
        case 114: f_struct_114(th);
        break;
        case 115: f_struct_115(th);
        break;
        case 116: f_struct_116(th);
        break;
        case 117: f_struct_117(th);
        break;
        case 118: f_struct_118(th);
        break;
        case 119: f_struct_119(th);
        break;
      }
    }
    return;
  }
