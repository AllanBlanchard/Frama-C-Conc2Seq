[kernel] Parsing tests/variables/variables.c (with preprocessing)
[c2s] Generating f_char_17 function
[c2s] Finalizing
[c2s] Generating f_char_18 function
[c2s] Finalizing
[c2s] Generating f_char_20 function
[c2s] Finalizing
[c2s] Generating f_char_21 function
[c2s] Finalizing
[c2s] Generating f_char_23 function
[c2s] Finalizing
[c2s] Generating f_char_65 function
[c2s] Finalizing
[c2s] Generating f_char_66 function
[c2s] Finalizing
[c2s] Generating f_char_67 function
[c2s] Finalizing
[c2s] Generating f_char_68 function
[c2s] Finalizing
[c2s] Generating f_char_69 function
[c2s] Finalizing
[c2s] Generating f_char_70 function
[c2s] Finalizing
[c2s] Generating f_char_29 function
[c2s] Finalizing
[c2s] Generating f_char_51 function
[c2s] Finalizing
[c2s] Generating f_int_1 function
[c2s] Finalizing
[c2s] Generating f_int_2 function
[c2s] Finalizing
[c2s] Generating f_int_4 function
[c2s] Finalizing
[c2s] Generating f_int_5 function
[c2s] Finalizing
[c2s] Generating f_int_7 function
[c2s] Finalizing
[c2s] Generating f_int_58 function
[c2s] Finalizing
[c2s] Generating f_int_59 function
[c2s] Finalizing
[c2s] Generating f_int_60 function
[c2s] Finalizing
[c2s] Generating f_int_61 function
[c2s] Finalizing
[c2s] Generating f_int_62 function
[c2s] Finalizing
[c2s] Generating f_int_63 function
[c2s] Finalizing
[c2s] Generating f_int_13 function
[c2s] Finalizing
[c2s] Generating f_int_49 function
[c2s] Finalizing
[c2s] Generating f_struct_33 function
[c2s] Finalizing
[c2s] Generating f_struct_34 function
[c2s] Finalizing
[c2s] Generating f_struct_36 function
[c2s] Finalizing
[c2s] Generating f_struct_37 function
[c2s] Finalizing
[c2s] Generating f_struct_39 function
[c2s] Finalizing
[c2s] Generating f_struct_72 function
[c2s] Finalizing
[c2s] Generating f_struct_73 function
[c2s] Finalizing
[c2s] Generating f_struct_74 function
[c2s] Finalizing
[c2s] Generating f_struct_75 function
[c2s] Finalizing
[c2s] Generating f_struct_76 function
[c2s] Finalizing
[c2s] Generating f_struct_77 function
[c2s] Finalizing
[c2s] Generating f_struct_45 function
[c2s] Finalizing
[c2s] Generating f_struct_53 function
[c2s] Finalizing
[c2s] Generating interleaving function
[c2s] Building axiomatic block about simulating variables
[c2s] Building validity axiom for pc
[c2s] Building validity axiom for tl_tlpas
[c2s] Building validity axiom for tl_tlaps
[c2s] Building validity axiom for tl_tlas
[c2s] Building validity axiom for tl_tlps
[c2s] Building validity axiom for tl_tls
[c2s] Building validity axiom for tl_tlpac
[c2s] Building validity axiom for tl_tlapc
[c2s] Building validity axiom for tl_tlac
[c2s] Building validity axiom for tl_tlpc
[c2s] Building validity axiom for tl_tlc
[c2s] Building validity axiom for tl_tlpai
[c2s] Building validity axiom for tl_tlapi
[c2s] Building validity axiom for tl_tlai
[c2s] Building validity axiom for tl_tlpi
[c2s] Building validity axiom for tl_tli
[c2s] Building validity axiom for f_struct_fpa44
[c2s] Building validity axiom for f_struct_fap43
[c2s] Building validity axiom for f_struct_fa42
[c2s] Building validity axiom for f_char_fpa28
[c2s] Building validity axiom for f_char_fap27
[c2s] Building validity axiom for f_char_fa26
[c2s] Building validity axiom for f_int_fpa12
[c2s] Building validity axiom for f_int_fap11
[c2s] Building validity axiom for f_int_fa10
[c2s] Building validity axiom for f_struct_i
[c2s] Building validity axiom for f_struct_lpa
[c2s] Building validity axiom for f_struct_lap
[c2s] Building validity axiom for f_struct_la
[c2s] Building validity axiom for f_struct_lp
[c2s] Building validity axiom for f_struct_l
[c2s] Building validity axiom for f_struct_fpa
[c2s] Building validity axiom for f_struct_fap
[c2s] Building validity axiom for f_struct_fa
[c2s] Building validity axiom for f_struct_fp
[c2s] Building validity axiom for f_struct_f
[c2s] Building validity axiom for f_char_i
[c2s] Building validity axiom for f_char_lpa
[c2s] Building validity axiom for f_char_lap
[c2s] Building validity axiom for f_char_la
[c2s] Building validity axiom for f_char_lp
[c2s] Building validity axiom for f_char_l
[c2s] Building validity axiom for f_char_fpa
[c2s] Building validity axiom for f_char_fap
[c2s] Building validity axiom for f_char_fa
[c2s] Building validity axiom for f_char_fp
[c2s] Building validity axiom for f_char_f
[c2s] Building validity axiom for f_int_i
[c2s] Building validity axiom for f_int_lpa
[c2s] Building validity axiom for f_int_lap
[c2s] Building validity axiom for f_int_la
[c2s] Building validity axiom for f_int_lp
[c2s] Building validity axiom for f_int_l
[c2s] Building validity axiom for f_int_fpa
[c2s] Building validity axiom for f_int_fap
[c2s] Building validity axiom for f_int_fa
[c2s] Building validity axiom for f_int_fp
[c2s] Building validity axiom for f_int_f
[c2s] Building validity axiom for next_in_f_struct
[c2s] Building validity axiom for next_in_f_char
[c2s] Building validity axiom for next_in_f_int
[c2s] Building axiom about simulating variables separation
[c2s] warning: gpas is a pointer, separation with simulation is not currently supported (ignored)
[c2s] warning: gps is a pointer, separation with simulation is not currently supported (ignored)
[c2s] warning: gpac is a pointer, separation with simulation is not currently supported (ignored)
[c2s] warning: gpc is a pointer, separation with simulation is not currently supported (ignored)
[c2s] warning: gpai is a pointer, separation with simulation is not currently supported (ignored)
[c2s] warning: gpi is a pointer, separation with simulation is not currently supported (ignored)
[c2s] /* Generated by Frama-C */
      #include "stddef.h"
      int *pc;
      struct type (**tl_tlpas)[10];
      struct type *(*tl_tlaps)[10];
      struct type (*tl_tlas)[10];
      struct type **tl_tlps;
      struct type *tl_tls;
      char (**tl_tlpac)[10];
      char *(*tl_tlapc)[10];
      char (*tl_tlac)[10];
      char **tl_tlpc;
      char *tl_tlc;
      int (**tl_tlpai)[10];
      int *(*tl_tlapi)[10];
      int (*tl_tlai)[10];
      int **tl_tlpi;
      int *tl_tli;
      struct type *f_struct_fpa44;
      struct type **f_struct_fap43;
      struct type *f_struct_fa42;
      char *f_char_fpa28;
      char **f_char_fap27;
      char *f_char_fa26;
      int *f_int_fpa12;
      int **f_int_fap11;
      int *f_int_fa10;
      int *f_struct_i;
      struct type (**f_struct_lpa)[10];
      struct type *(*f_struct_lap)[10];
      struct type (*f_struct_la)[10];
      struct type **f_struct_lp;
      struct type *f_struct_l;
      struct type (**f_struct_fpa)[10];
      struct type ** /*[10]*/ *f_struct_fap;
      struct type * /*[10]*/ *f_struct_fa;
      struct type **f_struct_fp;
      struct type *f_struct_f;
      int *f_char_i;
      char (**f_char_lpa)[10];
      char *(*f_char_lap)[10];
      char (*f_char_la)[10];
      char **f_char_lp;
      char *f_char_l;
      char (**f_char_fpa)[10];
      char ** /*[10]*/ *f_char_fap;
      char * /*[10]*/ *f_char_fa;
      char **f_char_fp;
      char *f_char_f;
      int *f_int_i;
      int (**f_int_lpa)[10];
      int *(*f_int_lap)[10];
      int (*f_int_la)[10];
      int **f_int_lp;
      int *f_int_l;
      int (**f_int_fpa)[10];
      int ** /*[10]*/ *f_int_fap;
      int * /*[10]*/ *f_int_fa;
      int **f_int_fp;
      int *f_int_f;
      int *next_in_f_struct;
      int *next_in_f_char;
      int *next_in_f_int;
      /*@
      predicate valid_pc{L}(ℤ pc) =
        pc ≡ 0 ∨
        pc ≡ -91 ∨
        pc ≡ -74 ∨
        pc ≡ -57 ∨
        pc ≡ 77 ∨
        pc ≡ 76 ∨
        pc ≡ 75 ∨
        pc ≡ 74 ∨
        pc ≡ 73 ∨
        pc ≡ 72 ∨
        pc ≡ 70 ∨
        pc ≡ 69 ∨
        pc ≡ 68 ∨
        pc ≡ 67 ∨
        pc ≡ 66 ∨
        pc ≡ 65 ∨
        pc ≡ 63 ∨
        pc ≡ 62 ∨
        pc ≡ 61 ∨
        pc ≡ 60 ∨
        pc ≡ 59 ∨
        pc ≡ 58 ∨
        pc ≡ 53 ∨
        pc ≡ 51 ∨
        pc ≡ 49 ∨
        pc ≡ 45 ∨
        pc ≡ 39 ∨
        pc ≡ 37 ∨
        pc ≡ 36 ∨
        pc ≡ 34 ∨
        pc ≡ 33 ∨
        pc ≡ 29 ∨
        pc ≡ 23 ∨
        pc ≡ 21 ∨
        pc ≡ 20 ∨
        pc ≡ 18 ∨
        pc ≡ 17 ∨
        pc ≡ 13 ∨ pc ≡ 7 ∨ pc ≡ 5 ∨ pc ≡ 4 ∨ pc ≡ 2 ∨ pc ≡ 1;
       */
      /*@
      predicate valid_pcs{L}(ℤ th) =
        valid_pc(*(pc + th)) ∧
        valid_pc(*(next_in_f_struct + th)) ∧
        valid_pc(*(next_in_f_char + th)) ∧ valid_pc(*(next_in_f_int + th));
       */
      /*@
      axiomatic Simulation_axioms {
        predicate simulation{L}
          reads
          pc, tl_tlpas, tl_tlaps, tl_tlas, tl_tlps, tl_tls, tl_tlpac, tl_tlapc,
          tl_tlac, tl_tlpc, tl_tlc, tl_tlpai, tl_tlapi, tl_tlai, tl_tlpi, tl_tli,
          f_struct_fpa44, f_struct_fap43, f_struct_fa42, f_char_fpa28,
          f_char_fap27, f_char_fa26, f_int_fpa12, f_int_fap11, f_int_fa10,
          f_struct_i, f_struct_lpa, f_struct_lap, f_struct_la, f_struct_lp,
          f_struct_l, f_struct_fpa, f_struct_fap, f_struct_fa, f_struct_fp,
          f_struct_f, f_char_i, f_char_lpa, f_char_lap, f_char_la, f_char_lp,
          f_char_l, f_char_fpa, f_char_fap, f_char_fa, f_char_fp, f_char_f,
          f_int_i, f_int_lpa, f_int_lap, f_int_la, f_int_lp, f_int_l, f_int_fpa,
          f_int_fap, f_int_fa, f_int_fp, f_int_f, next_in_f_struct, next_in_f_char,
          next_in_f_int;
        
        axiom all_separated{L}:
          simulation ⇒
          \separated(
            &gaps[0 .. 10 - 1], &gas[0 .. 10 - 1], &gs, &gapc[0 .. 10 - 1],
            &gac[0 .. 10 - 1], &gc, &gapi[0 .. 10 - 1], &gai[0 .. 10 - 1], &gi,
            &world, pc + (0 .. MAX_THREAD - 1), tl_tlpas + (0 .. MAX_THREAD - 1),
            tl_tlaps + (0 .. MAX_THREAD - 1), tl_tlas + (0 .. MAX_THREAD - 1),
            tl_tlps + (0 .. MAX_THREAD - 1), tl_tls + (0 .. MAX_THREAD - 1),
            tl_tlpac + (0 .. MAX_THREAD - 1), tl_tlapc + (0 .. MAX_THREAD - 1),
            tl_tlac + (0 .. MAX_THREAD - 1), tl_tlpc + (0 .. MAX_THREAD - 1),
            tl_tlc + (0 .. MAX_THREAD - 1), tl_tlpai + (0 .. MAX_THREAD - 1),
            tl_tlapi + (0 .. MAX_THREAD - 1), tl_tlai + (0 .. MAX_THREAD - 1),
            tl_tlpi + (0 .. MAX_THREAD - 1), tl_tli + (0 .. MAX_THREAD - 1),
            f_struct_fpa44 + (0 .. MAX_THREAD - 1),
            f_struct_fap43 + (0 .. MAX_THREAD - 1),
            f_struct_fa42 + (0 .. MAX_THREAD - 1),
            f_char_fpa28 + (0 .. MAX_THREAD - 1),
            f_char_fap27 + (0 .. MAX_THREAD - 1),
            f_char_fa26 + (0 .. MAX_THREAD - 1),
            f_int_fpa12 + (0 .. MAX_THREAD - 1),
            f_int_fap11 + (0 .. MAX_THREAD - 1),
            f_int_fa10 + (0 .. MAX_THREAD - 1), f_struct_i + (0 .. MAX_THREAD - 1),
            f_struct_lpa + (0 .. MAX_THREAD - 1),
            f_struct_lap + (0 .. MAX_THREAD - 1),
            f_struct_la + (0 .. MAX_THREAD - 1),
            f_struct_lp + (0 .. MAX_THREAD - 1),
            f_struct_l + (0 .. MAX_THREAD - 1),
            f_struct_fpa + (0 .. MAX_THREAD - 1),
            f_struct_fap + (0 .. MAX_THREAD - 1),
            f_struct_fa + (0 .. MAX_THREAD - 1),
            f_struct_fp + (0 .. MAX_THREAD - 1),
            f_struct_f + (0 .. MAX_THREAD - 1), f_char_i + (0 .. MAX_THREAD - 1),
            f_char_lpa + (0 .. MAX_THREAD - 1), f_char_lap + (0 .. MAX_THREAD - 1),
            f_char_la + (0 .. MAX_THREAD - 1), f_char_lp + (0 .. MAX_THREAD - 1),
            f_char_l + (0 .. MAX_THREAD - 1), f_char_fpa + (0 .. MAX_THREAD - 1),
            f_char_fap + (0 .. MAX_THREAD - 1), f_char_fa + (0 .. MAX_THREAD - 1),
            f_char_fp + (0 .. MAX_THREAD - 1), f_char_f + (0 .. MAX_THREAD - 1),
            f_int_i + (0 .. MAX_THREAD - 1), f_int_lpa + (0 .. MAX_THREAD - 1),
            f_int_lap + (0 .. MAX_THREAD - 1), f_int_la + (0 .. MAX_THREAD - 1),
            f_int_lp + (0 .. MAX_THREAD - 1), f_int_l + (0 .. MAX_THREAD - 1),
            f_int_fpa + (0 .. MAX_THREAD - 1), f_int_fap + (0 .. MAX_THREAD - 1),
            f_int_fa + (0 .. MAX_THREAD - 1), f_int_fp + (0 .. MAX_THREAD - 1),
            f_int_f + (0 .. MAX_THREAD - 1),
            next_in_f_struct + (0 .. MAX_THREAD - 1),
            next_in_f_char + (0 .. MAX_THREAD - 1),
            next_in_f_int + (0 .. MAX_THREAD - 1)
            );
        
        axiom pc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(pc + j));
        
        axiom tl_tlpas_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpas + j));
        
        axiom tl_tlaps_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlaps + j));
        
        axiom tl_tlas_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlas + j));
        
        axiom tl_tlps_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlps + j));
        
        axiom tl_tls_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tls + j));
        
        axiom tl_tlpac_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpac + j));
        
        axiom tl_tlapc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapc + j));
        
        axiom tl_tlac_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlac + j));
        
        axiom tl_tlpc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpc + j));
        
        axiom tl_tlc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlc + j));
        
        axiom tl_tlpai_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpai + j));
        
        axiom tl_tlapi_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapi + j));
        
        axiom tl_tlai_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlai + j));
        
        axiom tl_tlpi_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpi + j));
        
        axiom tl_tli_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tli + j));
        
        axiom f_struct_fpa44_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa44 + j));
        
        axiom f_struct_fap43_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap43 + j));
        
        axiom f_struct_fa42_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa42 + j));
        
        axiom f_char_fpa28_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa28 + j));
        
        axiom f_char_fap27_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap27 + j));
        
        axiom f_char_fa26_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa26 + j));
        
        axiom f_int_fpa12_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa12 + j));
        
        axiom f_int_fap11_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap11 + j));
        
        axiom f_int_fa10_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa10 + j));
        
        axiom f_struct_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_i + j));
        
        axiom f_struct_lpa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lpa + j));
        
        axiom f_struct_lap_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lap + j));
        
        axiom f_struct_la_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_la + j));
        
        axiom f_struct_lp_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lp + j));
        
        axiom f_struct_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_l + j));
        
        axiom f_struct_fpa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa + j));
        
        axiom f_struct_fap_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap + j));
        
        axiom f_struct_fa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa + j));
        
        axiom f_struct_fp_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fp + j));
        
        axiom f_struct_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_f + j));
        
        axiom f_char_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_i + j));
        
        axiom f_char_lpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lpa + j));
        
        axiom f_char_lap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lap + j));
        
        axiom f_char_la_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_la + j));
        
        axiom f_char_lp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lp + j));
        
        axiom f_char_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_l + j));
        
        axiom f_char_fpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa + j));
        
        axiom f_char_fap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap + j));
        
        axiom f_char_fa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa + j));
        
        axiom f_char_fp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fp + j));
        
        axiom f_char_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_f + j));
        
        axiom f_int_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_i + j));
        
        axiom f_int_lpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lpa + j));
        
        axiom f_int_lap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lap + j));
        
        axiom f_int_la_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_la + j));
        
        axiom f_int_lp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lp + j));
        
        axiom f_int_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_l + j));
        
        axiom f_int_fpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa + j));
        
        axiom f_int_fap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap + j));
        
        axiom f_int_fa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa + j));
        
        axiom f_int_fp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fp + j));
        
        axiom f_int_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_f + j));
        
        axiom next_in_f_struct_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_struct + j));
        
        axiom next_in_f_char_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_char + j));
        
        axiom next_in_f_int_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_int + j));
        
        }
       */
      struct type {
         int x ;
         char y ;
      };
      /*@
      predicate simulation{L}
        reads
        pc, tl_tlpas, tl_tlaps, tl_tlas, tl_tlps, tl_tls, tl_tlpac, tl_tlapc,
        tl_tlac, tl_tlpc, tl_tlc, tl_tlpai, tl_tlapi, tl_tlai, tl_tlpi, tl_tli,
        f_struct_fpa44, f_struct_fap43, f_struct_fa42, f_char_fpa28, f_char_fap27,
        f_char_fa26, f_int_fpa12, f_int_fap11, f_int_fa10, f_struct_i,
        f_struct_lpa, f_struct_lap, f_struct_la, f_struct_lp, f_struct_l,
        f_struct_fpa, f_struct_fap, f_struct_fa, f_struct_fp, f_struct_f, f_char_i,
        f_char_lpa, f_char_lap, f_char_la, f_char_lp, f_char_l, f_char_fpa,
        f_char_fap, f_char_fa, f_char_fp, f_char_f, f_int_i, f_int_lpa, f_int_lap,
        f_int_la, f_int_lp, f_int_l, f_int_fpa, f_int_fap, f_int_fa, f_int_fp,
        f_int_f, next_in_f_struct, next_in_f_char, next_in_f_int;
       */
      /*@
      axiomatic thread_variables_properties {
        logic ℤ MAX_THREAD
          reads \nothing;
        
        axiom some_threads: 0 < MAX_THREAD;
        
        }
       */
      /*@ predicate valid_thread_id(ℤ th) = 0 ≤ th < MAX_THREAD;
      
      */
      /*@ ghost size_t world; */
      /*@ ensures valid_thread_id(\result);
          atomic \true;
          assigns world; */
      size_t some_thread();
      
      int gi;
      int *gpi;
      int gai[10];
      int *gapi[10];
      int (*gpai)[10];
      char gc;
      char *gpc;
      char gac[10];
      char *gapc[10];
      char (*gpac)[10];
      struct type gs;
      struct type *gps;
      struct type gas[10];
      struct type *gaps[10];
      struct type (*gpas)[10];
      /*@
      axiomatic Simulation_axioms {
        predicate simulation{L}
          reads
          pc, tl_tlpas, tl_tlaps, tl_tlas, tl_tlps, tl_tls, tl_tlpac, tl_tlapc,
          tl_tlac, tl_tlpc, tl_tlc, tl_tlpai, tl_tlapi, tl_tlai, tl_tlpi, tl_tli,
          f_struct_fpa44, f_struct_fap43, f_struct_fa42, f_char_fpa28,
          f_char_fap27, f_char_fa26, f_int_fpa12, f_int_fap11, f_int_fa10,
          f_struct_i, f_struct_lpa, f_struct_lap, f_struct_la, f_struct_lp,
          f_struct_l, f_struct_fpa, f_struct_fap, f_struct_fa, f_struct_fp,
          f_struct_f, f_char_i, f_char_lpa, f_char_lap, f_char_la, f_char_lp,
          f_char_l, f_char_fpa, f_char_fap, f_char_fa, f_char_fp, f_char_f,
          f_int_i, f_int_lpa, f_int_lap, f_int_la, f_int_lp, f_int_l, f_int_fpa,
          f_int_fap, f_int_fa, f_int_fp, f_int_f, next_in_f_struct, next_in_f_char,
          next_in_f_int;
        
        axiom all_separated{L}:
          simulation ⇒
          \separated(
            &gaps[0 .. 10 - 1], &gas[0 .. 10 - 1], &gs, &gapc[0 .. 10 - 1],
            &gac[0 .. 10 - 1], &gc, &gapi[0 .. 10 - 1], &gai[0 .. 10 - 1], &gi,
            &world, pc + (0 .. MAX_THREAD - 1), tl_tlpas + (0 .. MAX_THREAD - 1),
            tl_tlaps + (0 .. MAX_THREAD - 1), tl_tlas + (0 .. MAX_THREAD - 1),
            tl_tlps + (0 .. MAX_THREAD - 1), tl_tls + (0 .. MAX_THREAD - 1),
            tl_tlpac + (0 .. MAX_THREAD - 1), tl_tlapc + (0 .. MAX_THREAD - 1),
            tl_tlac + (0 .. MAX_THREAD - 1), tl_tlpc + (0 .. MAX_THREAD - 1),
            tl_tlc + (0 .. MAX_THREAD - 1), tl_tlpai + (0 .. MAX_THREAD - 1),
            tl_tlapi + (0 .. MAX_THREAD - 1), tl_tlai + (0 .. MAX_THREAD - 1),
            tl_tlpi + (0 .. MAX_THREAD - 1), tl_tli + (0 .. MAX_THREAD - 1),
            f_struct_fpa44 + (0 .. MAX_THREAD - 1),
            f_struct_fap43 + (0 .. MAX_THREAD - 1),
            f_struct_fa42 + (0 .. MAX_THREAD - 1),
            f_char_fpa28 + (0 .. MAX_THREAD - 1),
            f_char_fap27 + (0 .. MAX_THREAD - 1),
            f_char_fa26 + (0 .. MAX_THREAD - 1),
            f_int_fpa12 + (0 .. MAX_THREAD - 1),
            f_int_fap11 + (0 .. MAX_THREAD - 1),
            f_int_fa10 + (0 .. MAX_THREAD - 1), f_struct_i + (0 .. MAX_THREAD - 1),
            f_struct_lpa + (0 .. MAX_THREAD - 1),
            f_struct_lap + (0 .. MAX_THREAD - 1),
            f_struct_la + (0 .. MAX_THREAD - 1),
            f_struct_lp + (0 .. MAX_THREAD - 1),
            f_struct_l + (0 .. MAX_THREAD - 1),
            f_struct_fpa + (0 .. MAX_THREAD - 1),
            f_struct_fap + (0 .. MAX_THREAD - 1),
            f_struct_fa + (0 .. MAX_THREAD - 1),
            f_struct_fp + (0 .. MAX_THREAD - 1),
            f_struct_f + (0 .. MAX_THREAD - 1), f_char_i + (0 .. MAX_THREAD - 1),
            f_char_lpa + (0 .. MAX_THREAD - 1), f_char_lap + (0 .. MAX_THREAD - 1),
            f_char_la + (0 .. MAX_THREAD - 1), f_char_lp + (0 .. MAX_THREAD - 1),
            f_char_l + (0 .. MAX_THREAD - 1), f_char_fpa + (0 .. MAX_THREAD - 1),
            f_char_fap + (0 .. MAX_THREAD - 1), f_char_fa + (0 .. MAX_THREAD - 1),
            f_char_fp + (0 .. MAX_THREAD - 1), f_char_f + (0 .. MAX_THREAD - 1),
            f_int_i + (0 .. MAX_THREAD - 1), f_int_lpa + (0 .. MAX_THREAD - 1),
            f_int_lap + (0 .. MAX_THREAD - 1), f_int_la + (0 .. MAX_THREAD - 1),
            f_int_lp + (0 .. MAX_THREAD - 1), f_int_l + (0 .. MAX_THREAD - 1),
            f_int_fpa + (0 .. MAX_THREAD - 1), f_int_fap + (0 .. MAX_THREAD - 1),
            f_int_fa + (0 .. MAX_THREAD - 1), f_int_fp + (0 .. MAX_THREAD - 1),
            f_int_f + (0 .. MAX_THREAD - 1),
            next_in_f_struct + (0 .. MAX_THREAD - 1),
            next_in_f_char + (0 .. MAX_THREAD - 1),
            next_in_f_int + (0 .. MAX_THREAD - 1)
            );
        
        axiom pc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(pc + j));
        
        axiom tl_tlpas_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpas + j));
        
        axiom tl_tlaps_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlaps + j));
        
        axiom tl_tlas_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlas + j));
        
        axiom tl_tlps_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlps + j));
        
        axiom tl_tls_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tls + j));
        
        axiom tl_tlpac_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpac + j));
        
        axiom tl_tlapc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapc + j));
        
        axiom tl_tlac_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlac + j));
        
        axiom tl_tlpc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpc + j));
        
        axiom tl_tlc_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlc + j));
        
        axiom tl_tlpai_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpai + j));
        
        axiom tl_tlapi_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlapi + j));
        
        axiom tl_tlai_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlai + j));
        
        axiom tl_tlpi_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tlpi + j));
        
        axiom tl_tli_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(tl_tli + j));
        
        axiom f_struct_fpa44_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa44 + j));
        
        axiom f_struct_fap43_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap43 + j));
        
        axiom f_struct_fa42_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa42 + j));
        
        axiom f_char_fpa28_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa28 + j));
        
        axiom f_char_fap27_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap27 + j));
        
        axiom f_char_fa26_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa26 + j));
        
        axiom f_int_fpa12_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa12 + j));
        
        axiom f_int_fap11_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap11 + j));
        
        axiom f_int_fa10_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa10 + j));
        
        axiom f_struct_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_i + j));
        
        axiom f_struct_lpa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lpa + j));
        
        axiom f_struct_lap_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lap + j));
        
        axiom f_struct_la_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_la + j));
        
        axiom f_struct_lp_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_lp + j));
        
        axiom f_struct_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_l + j));
        
        axiom f_struct_fpa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fpa + j));
        
        axiom f_struct_fap_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fap + j));
        
        axiom f_struct_fa_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fa + j));
        
        axiom f_struct_fp_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_fp + j));
        
        axiom f_struct_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_struct_f + j));
        
        axiom f_char_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_i + j));
        
        axiom f_char_lpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lpa + j));
        
        axiom f_char_lap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lap + j));
        
        axiom f_char_la_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_la + j));
        
        axiom f_char_lp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_lp + j));
        
        axiom f_char_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_l + j));
        
        axiom f_char_fpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fpa + j));
        
        axiom f_char_fap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fap + j));
        
        axiom f_char_fa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fa + j));
        
        axiom f_char_fp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_fp + j));
        
        axiom f_char_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_char_f + j));
        
        axiom f_int_i_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_i + j));
        
        axiom f_int_lpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lpa + j));
        
        axiom f_int_lap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lap + j));
        
        axiom f_int_la_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_la + j));
        
        axiom f_int_lp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_lp + j));
        
        axiom f_int_l_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_l + j));
        
        axiom f_int_fpa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fpa + j));
        
        axiom f_int_fap_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fap + j));
        
        axiom f_int_fa_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fa + j));
        
        axiom f_int_fp_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_fp + j));
        
        axiom f_int_f_is_valid{L}:
          simulation ⇒ (∀ ℤ j; valid_thread_id(j) ⇒ \valid(f_int_f + j));
        
        axiom next_in_f_struct_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_struct + j));
        
        axiom next_in_f_char_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_char + j));
        
        axiom next_in_f_int_is_valid{L}:
          simulation ⇒
          (∀ ℤ j; valid_thread_id(j) ⇒ \valid(next_in_f_int + j));
        
        }
      
      */
      /*@ requires *(pc + th) ≡ -57;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 1;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void init_formals_f_int(unsigned int th);
      
      /*@ requires *(pc + th) ≡ -74;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 17;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void init_formals_f_char(unsigned int th);
      
      /*@ requires *(pc + th) ≡ -91;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 33;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void init_formals_f_struct(unsigned int th);
      
      /*@ requires *(pc + th) ≡ 1;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 2;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_1(unsigned int th)
      {
        *(f_int_l + th) = *(f_int_f + th);
        *(pc + th) = 2;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 2;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 4;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_2(unsigned int th)
      {
        *(f_int_lp + th) = *(f_int_fp + th);
        *(pc + th) = 4;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 4;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 5;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_4(unsigned int th)
      {
        *(f_int_i + th) = 0;
        *(pc + th) = 5;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 5;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 7;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_5(unsigned int th)
      {
        *(pc + th) = 7;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 7;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 58 ∨ *(pc + th) ≡ 49;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_7(unsigned int th)
      {
        if (*(f_int_i + th) < 10) *(pc + th) = 58; else *(pc + th) = 49;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 13;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 5;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_13(unsigned int th)
      {
        (*(f_int_i + th)) ++;
        *(pc + th) = 5;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 17;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 18;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_17(unsigned int th)
      {
        *(f_char_l + th) = *(f_char_f + th);
        *(pc + th) = 18;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 18;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 20;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_18(unsigned int th)
      {
        *(f_char_lp + th) = *(f_char_fp + th);
        *(pc + th) = 20;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 20;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 21;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_20(unsigned int th)
      {
        *(f_char_i + th) = 0;
        *(pc + th) = 21;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 21;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 23;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_21(unsigned int th)
      {
        *(pc + th) = 23;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 23;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 65 ∨ *(pc + th) ≡ 51;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_23(unsigned int th)
      {
        if (*(f_char_i + th) < 10) *(pc + th) = 65; else *(pc + th) = 51;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 29;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 21;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_29(unsigned int th)
      {
        (*(f_char_i + th)) ++;
        *(pc + th) = 21;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 33;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 34;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_33(unsigned int th)
      {
        *(f_struct_l + th) = *(f_struct_f + th);
        *(pc + th) = 34;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 34;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 36;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_34(unsigned int th)
      {
        *(f_struct_lp + th) = *(f_struct_fp + th);
        *(pc + th) = 36;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 36;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 37;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_36(unsigned int th)
      {
        *(f_struct_i + th) = 0;
        *(pc + th) = 37;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 37;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 39;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_37(unsigned int th)
      {
        *(pc + th) = 39;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 39;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 72 ∨ *(pc + th) ≡ 53;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_39(unsigned int th)
      {
        if (*(f_struct_i + th) < 10) *(pc + th) = 72; else *(pc + th) = 53;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 45;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 37;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_45(unsigned int th)
      {
        (*(f_struct_i + th)) ++;
        *(pc + th) = 37;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 49;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_49(unsigned int th)
      {
        *(pc + th) = *(next_in_f_int + th);
        return;
      }
      
      /*@ requires *(pc + th) ≡ 51;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_51(unsigned int th)
      {
        *(pc + th) = *(next_in_f_char + th);
        return;
      }
      
      /*@ requires *(pc + th) ≡ 53;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_53(unsigned int th)
      {
        *(pc + th) = *(next_in_f_struct + th);
        return;
      }
      
      /*@ requires *(pc + th) ≡ 58;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 59;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_58(unsigned int th)
      {
        *(f_int_fa10 + th) = *(*(f_int_fa + th) + *(f_int_i + th));
        *(pc + th) = 59;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 59;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 60;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_59(unsigned int th)
      {
        (*(f_int_la + th))[*(f_int_i + th)] = *(f_int_fa10 + th);
        *(pc + th) = 60;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 60;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 61;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_60(unsigned int th)
      {
        *(f_int_fap11 + th) = *(*(f_int_fap + th) + *(f_int_i + th));
        *(pc + th) = 61;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 61;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 62;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_61(unsigned int th)
      {
        (*(f_int_lap + th))[*(f_int_i + th)] = *(f_int_fap11 + th);
        *(pc + th) = 62;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 62;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 63;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_62(unsigned int th)
      {
        *(f_int_fpa12 + th) = (*(*(f_int_fpa + th) + *(f_int_i + th)))[0];
        *(pc + th) = 63;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 63;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 13;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_int_63(unsigned int th)
      {
        (*(*(f_int_lpa + th) + *(f_int_i + th)))[0] = *(f_int_fpa12 + th);
        *(pc + th) = 13;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 65;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 66;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_65(unsigned int th)
      {
        *(f_char_fa26 + th) = *(*(f_char_fa + th) + *(f_char_i + th));
        *(pc + th) = 66;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 66;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 67;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_66(unsigned int th)
      {
        (*(f_char_la + th))[*(f_char_i + th)] = *(f_char_fa26 + th);
        *(pc + th) = 67;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 67;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 68;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_67(unsigned int th)
      {
        *(f_char_fap27 + th) = *(*(f_char_fap + th) + *(f_char_i + th));
        *(pc + th) = 68;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 68;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 69;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_68(unsigned int th)
      {
        (*(f_char_lap + th))[*(f_char_i + th)] = *(f_char_fap27 + th);
        *(pc + th) = 69;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 69;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 70;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_69(unsigned int th)
      {
        *(f_char_fpa28 + th) = (*(*(f_char_fpa + th) + *(f_char_i + th)))[0];
        *(pc + th) = 70;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 70;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 29;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_char_70(unsigned int th)
      {
        (*(*(f_char_lpa + th) + *(f_char_i + th)))[0] = *(f_char_fpa28 + th);
        *(pc + th) = 29;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 72;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 73;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_72(unsigned int th)
      {
        *(f_struct_fa42 + th) = *(*(f_struct_fa + th) + *(f_struct_i + th));
        *(pc + th) = 73;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 73;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 74;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_73(unsigned int th)
      {
        (*(f_struct_la + th))[*(f_struct_i + th)] = *(f_struct_fa42 + th);
        *(pc + th) = 74;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 74;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 75;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_74(unsigned int th)
      {
        *(f_struct_fap43 + th) = *(*(f_struct_fap + th) + *(f_struct_i + th));
        *(pc + th) = 75;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 75;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 76;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_75(unsigned int th)
      {
        (*(f_struct_lap + th))[*(f_struct_i + th)] = *(f_struct_fap43 + th);
        *(pc + th) = 76;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 76;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 77;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_76(unsigned int th)
      {
        *(f_struct_fpa44 + th) = (*(*(f_struct_fpa + th) + *(f_struct_i + th)))[0];
        *(pc + th) = 77;
        return;
      }
      
      /*@ requires *(pc + th) ≡ 77;
          requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          requires valid_thread_id(th);
          ensures *(pc + th) ≡ 45;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void f_struct_77(unsigned int th)
      {
        (*(*(f_struct_lpa + th) + *(f_struct_i + th)))[0] = *(f_struct_fpa44 + th);
        *(pc + th) = 45;
        return;
      }
      
      /*@ requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
          ensures ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          ensures simulation;
       */
      void choose_call(unsigned int th);
      
      /*@ requires ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
          requires simulation;
       */
      void interleave(void)
      {
        unsigned int th;
        th = some_thread();
        /*@ loop invariant c2s: simulation;
            loop invariant c2s: ∀ ℤ j; valid_thread_id(j) ⇒ valid_pcs(j);
        */
        while (1) {
          th = some_thread();
          switch (*(pc + th)) {
            case 0: choose_call(th);
            break;
            case -57: init_formals_f_int(th);
            break;
            case -74: init_formals_f_char(th);
            break;
            case -91: init_formals_f_struct(th);
            break;
            case 1: f_int_1(th);
            break;
            case 2: f_int_2(th);
            break;
            case 4: f_int_4(th);
            break;
            case 5: f_int_5(th);
            break;
            case 7: f_int_7(th);
            break;
            case 13: f_int_13(th);
            break;
            case 17: f_char_17(th);
            break;
            case 18: f_char_18(th);
            break;
            case 20: f_char_20(th);
            break;
            case 21: f_char_21(th);
            break;
            case 23: f_char_23(th);
            break;
            case 29: f_char_29(th);
            break;
            case 33: f_struct_33(th);
            break;
            case 34: f_struct_34(th);
            break;
            case 36: f_struct_36(th);
            break;
            case 37: f_struct_37(th);
            break;
            case 39: f_struct_39(th);
            break;
            case 45: f_struct_45(th);
            break;
            case 49: f_int_49(th);
            break;
            case 51: f_char_51(th);
            break;
            case 53: f_struct_53(th);
            break;
            case 58: f_int_58(th);
            break;
            case 59: f_int_59(th);
            break;
            case 60: f_int_60(th);
            break;
            case 61: f_int_61(th);
            break;
            case 62: f_int_62(th);
            break;
            case 63: f_int_63(th);
            break;
            case 65: f_char_65(th);
            break;
            case 66: f_char_66(th);
            break;
            case 67: f_char_67(th);
            break;
            case 68: f_char_68(th);
            break;
            case 69: f_char_69(th);
            break;
            case 70: f_char_70(th);
            break;
            case 72: f_struct_72(th);
            break;
            case 73: f_struct_73(th);
            break;
            case 74: f_struct_74(th);
            break;
            case 75: f_struct_75(th);
            break;
            case 76: f_struct_76(th);
            break;
            case 77: f_struct_77(th);
            break;
          }
        }
        return;
      }
